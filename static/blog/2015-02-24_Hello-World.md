## Hello World

I've decided to create a blog - from scratch.

Unsatisified with bulky, hosted, blogging platforms, I've turned to [static webpage][wiki-static] generation.

GitHub's [Jekyll] project seems interesting but I'm not as familiar with [Ruby] as I am [Python].

[Pelican] seems to be popular but I'm not too particular about its codebase. [Hyde] looks wonderful - though extensive.

I enjoy simplicity and level of understanding of my code. So, I've decided to create a platform of my own - implementing elements familiar to me. This blog will chronicle its development from inception to everyday use.

I've dubbed this application *"**Noise** - a static webpage generator.*

#### Source Code

While this platform aims to serve my purposes, it will be developed in a modular fashion as to be utilized in other personal projects - or by others.

All source code for the application may be found in a [GitHub repository][repo-noise]. Please, feel free to [fork][github-fork] or make [pull requests][github-pull].

Additionally, the code behind this blog (generated by **Noise**) is available in a [repository][repo-blog] of its own.

### Humble Beginnings

To begin, we'll need a starting point. I'll review some general ideas.

Some functionality includes:

 * Console-based input
 * Static HTML generation
 * Static resource support

More advanced functionality includes:

 * [Flask] style [routes][Flask-routes]
 * [Jinja] template engine
 * [Markdown] content support

Note: The following code snippets are inteded merely for demonstration.

#### Parsing Arguments

A console application is created to accept arguments.

```python
import argparse

# initialize argument parser
parser = argparse.ArgumentParser(prog='noise',
    description="noise: a static webpage generator")
# include default 'version' mechanic
parser.add_argument('--version', action='version',
    version="%(prog)s {}".format(__version__))

# parse arguments
args = parser.parse_args()
```

This provides the following console interaction:

```
$ ./noise.py --help

usage: noise [-h] [--version]

noise: a static webpage generator

optional arguments:
  -h, --help  show this help message and exit
  --version   show program's version number and exit
```

Next, we'll need to provide actions for our application to perform.

##### Application Actions

The application will initially perform two basic actions:

 * `init` - Initialize the project directory
 * `build` - Generate static files

Note: Future support for `publish` will be provided with the intention of uploading the generated files to a target location.

For this, we'll create a sub-parser and add individual parsers for each action:

```python
# create 'action' subparsers
subparsers = parser.add_subparsers(dest='action',
    help="action to perform")
# create 'init' action subparser
init_parser = subparsers.add_parser('init',
    help="initialize project directory")
# create 'build' action subparser
build_parser = subparsers.add_parser('build',
    help="build project")
```

This now provides the following console interaction:

```
$ ./noise.py --help

usage: noise [-h] [--version] {init,build} ...

noise: a static webpage generator

positional arguments:
  {init,build}  action to perform
    init        initialize project directory
    build       build project
```

##### Project Path

In order to target a project, we'll need to pass its directory path to these actions:

```python
# add project 'path' argument to action subparsers
for p in (init_parser, build_parser):
    p.add_argument('path', help="project directory path")
```

Note: Support for initializing/building the current working directory may be supported in the future.

The console interaction for the init/build action now reads:

```
$ ./noise.py init --help

usage: noise init [-h] path

positional arguments:
  path        project directory path
```

###### Path Helper

Due to the extensive filesystem use of the application, a `Path` helper is created to aid in the handling of these paths. Its development can be followed in a [supplimental post][blog-path].

The module can be found [here][Path] and provides the following functionality:

```python
>>> from path import Path
>>> path = Path('/tmp')
>>> print path
/tmp
>>> print path('foo.txt')
/tmp/foo.txt
>>> print path.paths
('build', 'static', 'template')
>>> print path.build('bar.txt')
/tmp/build/bar.txt
```

##### Application Initialization

We'll create two placeholder methods to emulate the init/build actions:

```python
from path import Path

class Noise(object):
    def __init__(self, path):
        # initialize project path helper
        self.path = Path(path)

    def init(self):
        print "Initializing project '%s'" % self.path

    def build(self):
        print "Building project '%s'" % self.path
...

def main():
    ...

    # initialize project
    if args.action == 'init':
        Noise(args.path).init()
    # build project
    if args.action == 'build':
        Noise(args.path).build()
```

This ensures everything is working properly.

```
./noise.py init blog
Initialize project 'blog'
./noise.py build blog
Building project 'blog'
```

The path helper provides an [init()][Path-init] method to handle the creation of project directories.

```python
class Noise(object):
	...
    def init(self):
        # initialize paths
        self.path.init()
```

Calling this upon application initialization produces the following directory tree:

```
$ ./noise.py init blog

blog
|-- build
|-- static
`-- template
```

###### Project Boilerplate

Projects are actually Python [modules][Python-modules] themselves. As mentioned, [Flask] style [routes][Flask-routes] are used to manipulate the generation of files intended to serve a given URL.

A [Route] is a method, to which the [Page] object is passed. It exposes data used when rendering the page.

For example, a project's `__init__.py` file may contain the following `index.html` route:

```python
from noise import Noise

app = Noise(__file__)

@app.route('/')
def index(page):
    # set template variables
    page.data.update({
        'title': "Noise - a static webpage generator",
        'body':  "Hello World!"
    })
```

Once again, a helper is created to aid in handling these routes. Its development can be followed in a [supplimental post][post-routes] and its module may be found [here][Route].

In order to initialize a project as a module, this boilerplate is written to its directory:

```python
class Noise(object):
    ...
    def init(self):
        ...
        # create project init file
        path = self.path('__init__.py')
        if not os.path.exists(path):
            from noise.route import BOILERPLATE
            with open(path, 'w') as f:
                f.write(BOILERPLATE)
```

The directory structure now reads:

```
blog
|-- build
|-- __init__.py
|-- static
`-- template
```

##### Building the Project

The project module is imported its application [build()][Noise-build] method is called:

```python
def main():
    ...
    # initialize project
    if args.action == 'init':
        Noise(args.path).init()
    # import and build project
    elif args.action == 'build':
        sys.path.insert(0, os.path.dirname(args.path))
        __import__(args.path).app.build()
```

The build method handles static resources and the rendering of pages.

###### Handling Static Resources

Static resources are copied from the static directory to the build directory:

```python
class Noise(object):
    ...
    def build(self):
        # clear build directory
        build_path = str(self.path.build)
        if os.path.exists(build_path):
            shutil.rmtree(build_path)

        # copy static contents to build path
        static_path = str(self.path.static)
        if os.path.exists(static_path):
            shutil.copytree(static_path, build_path)

        # recreate build directory
        else: os.mkdir(build_path)
```

###### Rendering Pages

The `Page` object handles rendering file to the build directory. Its development can be followed in a [supplimental post][blog-routespages] and its module may be found [here][Page].

The '[route]' [decorator](https://www.python.org/dev/peps/pep-0318) adds the callback methods defined in the project initialization file to a list of the application's routes. The [build()][Noise-build] method then creates [Page] objects for these routes and performs said callback:

```python
from noise.page import Page

class Noise(object):
    ...
    def build(self):
        ...
        # iterate routes
        for route, page in self.routes.items():
            # build page if callback passed
            if type(page) is not Page:
                # save callback
                callback = page
                # initialize page object
                page = Page(self, route)
                # perform callback on page
                callback(page)
            # render page
            page.render()
```

`Page` objects themselves may also be added to applications routes. This will allow future plugins to create routes in a more dynamic fashion.

### Test Drive

Now that we've covered the [Path], [Route], [Page], and the [Noise] application itself, we're ready create our initial build:

```
$ ./noise.py build blog

blog
|-- build
|   `-- index.html
|-- __init__.py
|-- static
`-- template
```

A browser directed to `file:///.../blog/build/index.html` displays "Hello World!" - success!

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>noise: a static website generator</title>
  </head>
  <body>
    Hello World!
  </body>
</html>
```

Onward to features!


[Ruby]: https://www.ruby-lang.org
[Jekyll]: http://jekyllrb.com
[Pelican]: http://blog.getpelican.com
[Hyde]: http://hyde.github.io
[Python]: https://www.python.org

[Flask]: http://flask.pocoo.org
[Flask-routes]: http://flask.pocoo.org/docs/0.10/api/#url-route-registrations
[Jinja]: http://jinja.pocoo.org
[Markdown]: http://daringfireball.net/projects/markdown

[repo-noise]: https://github.com/ryonsherman/noise
[repo-blog]: https://github.com/ryonsherman/ryonsherman.github.io

[blog-path]: /blog/2015-02-24_Follow-the-Path.html
[blog-routespages]: /blog/2014-02-24_Routes-Pages-and-Templates_Oh-My.html

[Noise]: https://github.com/ryonsherman/noise/blob/d27dbee9e46a2168100a9e5df4f7ce0a99fed83b/src/noise/__init__.py
[Noise-build]: https://github.com/ryonsherman/noise/blob/d27dbee9e46a2168100a9e5df4f7ce0a99fed83b/src/noise/__init__.py#L42
[Path]: https://github.com/ryonsherman/noise/blob/d27dbee9e46a2168100a9e5df4f7ce0a99fed83b/src/noise/path.py
[Path-init]: https://github.com/ryonsherman/noise/blob/d27dbee9e46a2168100a9e5df4f7ce0a99fed83b/src/noise/path.py#L51
[Route]: https://github.com/ryonsherman/noise/blob/d27dbee9e46a2168100a9e5df4f7ce0a99fed83b/src/noise/route.py
[Route-decorator]: https://github.com/ryonsherman/noise/blob/d27dbee9e46a2168100a9e5df4f7ce0a99fed83b/src/noise/route.py#L44
[Page]: https://github.com/ryonsherman/noise/blob/d27dbee9e46a2168100a9e5df4f7ce0a99fed83b/src/noise/page.py

[python-modules]: https://docs.python.org/2/tutorial/modules.html
[github-fork]: https://help.github.com/articles/fork-a-repo
[github-pull]: https://help.github.com/articles/using-pull-requests
[wiki-static]: http://en.wikipedia.org/wiki/Static_web_page
